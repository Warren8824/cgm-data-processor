{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"CGM Data Processor <p>A robust Python framework for processing and analyzing diabetes device data</p> <p> </p>"},{"location":"#process-your-diabetes-data","title":"\ud83d\udcc8 Process Your Diabetes Data","text":"<p>Analyze data from multiple diabetes management systems including XDrip+, Dexcom, and Freestyle Libre. Handle CGM readings, insulin doses, carbs, and treatment notes with confidence.</p>"},{"location":"#cgm-analysis","title":"\ud83e\ude78 CGM Analysis","text":"<ul> <li>Gap detection</li> <li>Noise filtering</li> <li>Quality metrics</li> </ul>"},{"location":"#treatment-data","title":"\ud83d\udc89 Treatment Data","text":"<ul> <li>Insulin doses</li> <li>Carb intake</li> <li>Event notes</li> </ul>"},{"location":"#advanced-features","title":"\ud83d\ude80 Advanced Features","text":"<ul> <li>Automated format detection</li> <li>Data alignment</li> <li>Flexible export options</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from src.core.format_registry import FormatRegistry\nfrom src.file_parser.format_detector import FormatDetector\nfrom src.processors import DataProcessor\n\n# Initialize format detection\nregistry = FormatRegistry()\ndetector = FormatDetector(registry)\n\n# Process file\nformat, _, _ = detector.detect_format(\"my_data.sqlite\")\nprocessed_data = process_file(\"my_data.sqlite\")\n</code></pre>"},{"location":"#key-features","title":"\ud83d\udca1 Key Features","text":"<ul> <li>Automated format detection for multiple data sources</li> <li>Robust data validation and cleaning</li> <li>Gap detection and interpolation for CGM data</li> <li>Treatment classification and verification</li> <li>Flexible data export options</li> </ul>"},{"location":"#responsible-use","title":"\ud83d\udee1\ufe0f Responsible Use","text":"This tool is designed for data analysis only. Not intended for real-time monitoring or medical decision making. Always consult healthcare providers for medical advice."},{"location":"api/core/","title":"Core API Reference","text":""},{"location":"api/core/#data-types-module","title":"Data Types Module","text":"<p>Module Location</p> <p><code>src/core/data_types.py</code></p>"},{"location":"api/core/#src.core.data_types","title":"<code>src.core.data_types</code>","text":"<p>Core data type definitions for diabetes data processing.</p> <p>This module defines the core data types and structures used for processing diabetes device data exports. It supports multiple file formats, different units of measurement, and various data types commonly found in diabetes management tools.</p> The structure allows for <ul> <li>Multiple files in a single format</li> <li>Multiple data types per table</li> <li>Different file types (SQLite, CSV, etc.)</li> <li>Flexible column mapping</li> <li>Primary/secondary data distinction</li> </ul>"},{"location":"api/core/#src.core.data_types.ColumnMapping","title":"<code>ColumnMapping</code>  <code>dataclass</code>","text":"<p>Maps source columns to standardized data types.</p> <p>Parameters:</p> Name Type Description Default <code>source_name</code> <code>str</code> <p>Original column name in the data source</p> required <code>data_type</code> <code>Optional[DataType]</code> <p>Type of data this column contains (if applicable - Any column can be</p> <code>None</code> <code>unit</code> <code>Optional[Unit]</code> <p>Unit of measurement (if applicable)</p> <code>None</code> <code>requirement</code> <code>ColumnRequirement</code> <p>Type of requirement - default = REQUIRED_WITH_DATA</p> <code>REQUIRED_WITH_DATA</code> <code>is_primary</code> <code>bool</code> <p>Whether this is the primary column - default = True</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; glucose_column = ColumnMapping(\n...     source_name=\"calculated_value\",\n...     data_type=DataType.CGM,\n...     unit=Unit.MGDL,\n... )\n&gt;&gt;&gt; raw_glucose = ColumnMapping(\n...     source_name=\"raw_data\",\n...     data_type=DataType.CGM,\n...     requirement=ColumnRequirement.REQUIRED_NULLABLE,\n...     is_primary=False\n... )\n</code></pre> Source code in <code>src/core/data_types.py</code> <pre><code>@dataclass\nclass ColumnMapping:\n    \"\"\"Maps source columns to standardized data types.\n\n    Args:\n        source_name: Original column name in the data source\n        data_type: Type of data this column contains (if applicable - Any column can be\n        used for confirming device.)\n        unit: Unit of measurement (if applicable)\n        requirement: Type of requirement - default = REQUIRED_WITH_DATA\n        is_primary: Whether this is the primary column - default = True\n\n    Examples:\n        &gt;&gt;&gt; glucose_column = ColumnMapping(\n        ...     source_name=\"calculated_value\",\n        ...     data_type=DataType.CGM,\n        ...     unit=Unit.MGDL,\n        ... )\n        &gt;&gt;&gt; raw_glucose = ColumnMapping(\n        ...     source_name=\"raw_data\",\n        ...     data_type=DataType.CGM,\n        ...     requirement=ColumnRequirement.REQUIRED_NULLABLE,\n        ...     is_primary=False\n        ... )\n    \"\"\"\n\n    source_name: str\n    data_type: Optional[DataType] = None\n    unit: Optional[Unit] = None\n    requirement: ColumnRequirement = ColumnRequirement.REQUIRED_WITH_DATA\n    is_primary: bool = True\n</code></pre>"},{"location":"api/core/#src.core.data_types.ColumnRequirement","title":"<code>ColumnRequirement</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Defines how column should be validated and if data reading is required</p> Source code in <code>src/core/data_types.py</code> <pre><code>class ColumnRequirement(Enum):\n    \"\"\"Defines how column should be validated and if data reading is required\"\"\"\n\n    CONFIRMATION_ONLY = auto()  # Just needs to exist - no data read\n    REQUIRED_WITH_DATA = auto()  # Must exist - data read &amp; fail if not\n    REQUIRED_NULLABLE = auto()  # Must exist, can have all missing values - data read\n    OPTIONAL = auto()  # May or may not exist - data read\n</code></pre>"},{"location":"api/core/#src.core.data_types.DataType","title":"<code>DataType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Core diabetes data types.</p> Source code in <code>src/core/data_types.py</code> <pre><code>class DataType(Enum):\n    \"\"\"Core diabetes data types.\"\"\"\n\n    # CGM Data\n    CGM = auto()  # Continuous glucose monitoring data\n\n    # BGM Data\n    BGM = auto()  # Blood glucose meter readings\n\n    # Treatment Data\n    INSULIN = auto()  # Insulin doses\n    INSULIN_META = auto()  # Insulin metadata eg brand\n    CARBS = auto()  # Carbohydrate intake\n    NOTES = auto()  # Text notes/comments\n</code></pre>"},{"location":"api/core/#src.core.data_types.DeviceFormat","title":"<code>DeviceFormat</code>  <code>dataclass</code>","text":"<p>Complete format specification for a diabetes device data export.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the device/format</p> required <code>files</code> <code>List[FileConfig]</code> <p>List of file configurations</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; xdrip_format = DeviceFormat(\n...     name=\"xdrip_sqlite\",\n...     files=[sqlite_file]  # FileConfig from previous example\n... )\n</code></pre> Source code in <code>src/core/data_types.py</code> <pre><code>@dataclass\nclass DeviceFormat:\n    \"\"\"Complete format specification for a diabetes device data export.\n\n    Args:\n        name: Name of the device/format\n        files: List of file configurations\n\n    Examples:\n        &gt;&gt;&gt; xdrip_format = DeviceFormat(\n        ...     name=\"xdrip_sqlite\",\n        ...     files=[sqlite_file]  # FileConfig from previous example\n        ... )\n    \"\"\"\n\n    name: str\n    files: List[FileConfig]\n\n    def __post_init__(self):\n        \"\"\"Validate device format after initialization.\n\n        Raises:\n            FormatValidationError: If device format is invalid\n        \"\"\"\n        if not self.files:\n            raise FormatValidationError(\n                f\"Device format {self.name} must have at least one file defined\",\n                details={\"format_name\": self.name},\n            )\n\n    def __str__(self) -&gt; str:\n        \"\"\"String representation including available data types.\"\"\"\n        types = set()\n        for file_config in self.files:\n            for table in file_config.tables:\n                for column in table.columns:\n                    if column.is_primary:\n                        types.add(column.data_type.name)\n        return f\"{self.name} - Available data: {', '.join(sorted(types))}\"\n</code></pre>"},{"location":"api/core/#src.core.data_types.DeviceFormat.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate device format after initialization.</p> <p>Raises:</p> Type Description <code>FormatValidationError</code> <p>If device format is invalid</p> Source code in <code>src/core/data_types.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Validate device format after initialization.\n\n    Raises:\n        FormatValidationError: If device format is invalid\n    \"\"\"\n    if not self.files:\n        raise FormatValidationError(\n            f\"Device format {self.name} must have at least one file defined\",\n            details={\"format_name\": self.name},\n        )\n</code></pre>"},{"location":"api/core/#src.core.data_types.DeviceFormat.__str__","title":"<code>__str__()</code>","text":"<p>String representation including available data types.</p> Source code in <code>src/core/data_types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"String representation including available data types.\"\"\"\n    types = set()\n    for file_config in self.files:\n        for table in file_config.tables:\n            for column in table.columns:\n                if column.is_primary:\n                    types.add(column.data_type.name)\n    return f\"{self.name} - Available data: {', '.join(sorted(types))}\"\n</code></pre>"},{"location":"api/core/#src.core.data_types.FileConfig","title":"<code>FileConfig</code>  <code>dataclass</code>","text":"<p>Configuration for a specific file in a device format.</p> <p>Parameters:</p> Name Type Description Default <code>name_pattern</code> <code>str</code> <p>Pattern to match filename (e.g., \"*.sqlite\", \"glucose.csv\")</p> required <code>file_type</code> <code>FileType</code> <p>Type of the data file</p> required <code>tables</code> <code>List[TableStructure]</code> <p>List of table structures in the file</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; sqlite_file = FileConfig(\n...     name_pattern=\"*.sqlite\",\n...     file_type=FileType.SQLITE,\n...     tables=[bgreadings]  # TableStructure from previous example\n... )\n</code></pre> Source code in <code>src/core/data_types.py</code> <pre><code>@dataclass\nclass FileConfig:\n    \"\"\"Configuration for a specific file in a device format.\n\n    Args:\n        name_pattern: Pattern to match filename (e.g., \"*.sqlite\", \"glucose.csv\")\n        file_type: Type of the data file\n        tables: List of table structures in the file\n\n    Examples:\n        &gt;&gt;&gt; sqlite_file = FileConfig(\n        ...     name_pattern=\"*.sqlite\",\n        ...     file_type=FileType.SQLITE,\n        ...     tables=[bgreadings]  # TableStructure from previous example\n        ... )\n    \"\"\"\n\n    name_pattern: str\n    file_type: FileType\n    tables: List[TableStructure]\n\n    def __post_init__(self):\n        \"\"\"Validate file configuration after initialization.\n\n        Raises:\n            FormatValidationError: If file configuration is invalid\n        \"\"\"\n        if not self.tables:\n            raise FormatValidationError(\n                f\"File {self.name_pattern} must have at least one table defined\",\n                details={\"file_pattern\": self.name_pattern},\n            )\n\n        # For CSV files, ensure only one table with empty name\n        if self.file_type == FileType.CSV:\n            if len(self.tables) &gt; 1:\n                raise FormatValidationError(\n                    \"CSV files can only have one table structure\",\n                    details={\n                        \"file_pattern\": self.name_pattern,\n                        \"tables_count\": len(self.tables),\n                    },\n                )\n            if self.tables[0].name != \"\":\n                raise FormatValidationError(\n                    f\"CSV file table name should be empty string for file {self.name_pattern}\",\n                    details={\n                        \"file_pattern\": self.name_pattern,\n                        \"table_name\": self.tables[0].name,\n                    },\n                )\n</code></pre>"},{"location":"api/core/#src.core.data_types.FileConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate file configuration after initialization.</p> <p>Raises:</p> Type Description <code>FormatValidationError</code> <p>If file configuration is invalid</p> Source code in <code>src/core/data_types.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Validate file configuration after initialization.\n\n    Raises:\n        FormatValidationError: If file configuration is invalid\n    \"\"\"\n    if not self.tables:\n        raise FormatValidationError(\n            f\"File {self.name_pattern} must have at least one table defined\",\n            details={\"file_pattern\": self.name_pattern},\n        )\n\n    # For CSV files, ensure only one table with empty name\n    if self.file_type == FileType.CSV:\n        if len(self.tables) &gt; 1:\n            raise FormatValidationError(\n                \"CSV files can only have one table structure\",\n                details={\n                    \"file_pattern\": self.name_pattern,\n                    \"tables_count\": len(self.tables),\n                },\n            )\n        if self.tables[0].name != \"\":\n            raise FormatValidationError(\n                f\"CSV file table name should be empty string for file {self.name_pattern}\",\n                details={\n                    \"file_pattern\": self.name_pattern,\n                    \"table_name\": self.tables[0].name,\n                },\n            )\n</code></pre>"},{"location":"api/core/#src.core.data_types.FileType","title":"<code>FileType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Supported file types for diabetes data.</p> Source code in <code>src/core/data_types.py</code> <pre><code>class FileType(Enum):\n    \"\"\"Supported file types for diabetes data.\"\"\"\n\n    SQLITE = \"sqlite\"\n    CSV = \"csv\"\n    JSON = \"json\"\n    XML = \"xml\"\n</code></pre>"},{"location":"api/core/#src.core.data_types.TableStructure","title":"<code>TableStructure</code>  <code>dataclass</code>","text":"<p>Defines the structure of a data table.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Table name in the data source (empty string for CSV files)</p> required <code>timestamp_column</code> <code>str</code> <p>Name of the timestamp column</p> required <code>columns</code> <code>List[ColumnMapping]</code> <p>List of column mappings</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; bgreadings = TableStructure(\n...     name=\"bgreadings\",\n...     timestamp_column=\"timestamp\",\n...     columns=[\n...         ColumnMapping(\n...             source_name=\"calculated_value\",\n...             data_type=DataType.CGM,\n...             unit=Unit.MGDL\n...         ),\n...         ColumnMapping(\n...             source_name=\"raw_data\",\n...             data_type=DataType.CGM,\n...             requirement=ColumnRequirement.REQUIRED_NULLABLE,\n...             is_primary=False\n...         )\n...     ]\n... )\n</code></pre> Source code in <code>src/core/data_types.py</code> <pre><code>@dataclass\nclass TableStructure:\n    \"\"\"Defines the structure of a data table.\n\n    Args:\n        name: Table name in the data source (empty string for CSV files)\n        timestamp_column: Name of the timestamp column\n        columns: List of column mappings\n\n    Examples:\n        &gt;&gt;&gt; bgreadings = TableStructure(\n        ...     name=\"bgreadings\",\n        ...     timestamp_column=\"timestamp\",\n        ...     columns=[\n        ...         ColumnMapping(\n        ...             source_name=\"calculated_value\",\n        ...             data_type=DataType.CGM,\n        ...             unit=Unit.MGDL\n        ...         ),\n        ...         ColumnMapping(\n        ...             source_name=\"raw_data\",\n        ...             data_type=DataType.CGM,\n        ...             requirement=ColumnRequirement.REQUIRED_NULLABLE,\n        ...             is_primary=False\n        ...         )\n        ...     ]\n        ... )\n    \"\"\"\n\n    name: str\n    timestamp_column: str\n    columns: List[ColumnMapping]\n\n    def validate_columns(self):\n        \"\"\"Validate that table has at least one column defined.\n\n        Raises:\n            FormatValidationError: If table has no columns defined\n        \"\"\"\n        if not self.columns:\n            raise FormatValidationError(\n                f\"Table {self.name} must have at least one column defined\",\n                details={\"table_name\": self.name, \"columns_count\": 0},\n            )\n\n    def validate_unique_source_names(self):\n        \"\"\"Validate that all column names are unique.\n\n        Raises:\n            FormatValidationError: If duplicate column names are found\n        \"\"\"\n        column_names = [col.source_name for col in self.columns]\n        unique_names = set(column_names)\n        if len(column_names) != len(unique_names):\n            duplicates = [name for name in unique_names if column_names.count(name) &gt; 1]\n            raise FormatValidationError(\n                f\"Duplicate column names in table {self.name}\",\n                details={\"table_name\": self.name, \"duplicate_columns\": duplicates},\n            )\n\n    def validate_primary_columns(self):\n        \"\"\"Validate that each data type has at most one primary column.\n\n        Raises:\n            FormatValidationError: If multiple primary columns exist for any data type\n        \"\"\"\n        for data_type in DataType:\n            primary_columns = [\n                col.source_name\n                for col in self.columns\n                if col.data_type == data_type and col.is_primary\n            ]\n            if len(primary_columns) &gt; 1:\n                raise FormatValidationError(\n                    f\"Multiple primary columns for {data_type.value} in table {self.name}\",\n                    details={\n                        \"table_name\": self.name,\n                        \"data_type\": data_type.value,\n                        \"primary_columns\": primary_columns,\n                    },\n                )\n\n    def __post_init__(self):\n        self.validate_columns()\n        self.validate_unique_source_names()\n        self.validate_primary_columns()\n</code></pre>"},{"location":"api/core/#src.core.data_types.TableStructure.validate_columns","title":"<code>validate_columns()</code>","text":"<p>Validate that table has at least one column defined.</p> <p>Raises:</p> Type Description <code>FormatValidationError</code> <p>If table has no columns defined</p> Source code in <code>src/core/data_types.py</code> <pre><code>def validate_columns(self):\n    \"\"\"Validate that table has at least one column defined.\n\n    Raises:\n        FormatValidationError: If table has no columns defined\n    \"\"\"\n    if not self.columns:\n        raise FormatValidationError(\n            f\"Table {self.name} must have at least one column defined\",\n            details={\"table_name\": self.name, \"columns_count\": 0},\n        )\n</code></pre>"},{"location":"api/core/#src.core.data_types.TableStructure.validate_primary_columns","title":"<code>validate_primary_columns()</code>","text":"<p>Validate that each data type has at most one primary column.</p> <p>Raises:</p> Type Description <code>FormatValidationError</code> <p>If multiple primary columns exist for any data type</p> Source code in <code>src/core/data_types.py</code> <pre><code>def validate_primary_columns(self):\n    \"\"\"Validate that each data type has at most one primary column.\n\n    Raises:\n        FormatValidationError: If multiple primary columns exist for any data type\n    \"\"\"\n    for data_type in DataType:\n        primary_columns = [\n            col.source_name\n            for col in self.columns\n            if col.data_type == data_type and col.is_primary\n        ]\n        if len(primary_columns) &gt; 1:\n            raise FormatValidationError(\n                f\"Multiple primary columns for {data_type.value} in table {self.name}\",\n                details={\n                    \"table_name\": self.name,\n                    \"data_type\": data_type.value,\n                    \"primary_columns\": primary_columns,\n                },\n            )\n</code></pre>"},{"location":"api/core/#src.core.data_types.TableStructure.validate_unique_source_names","title":"<code>validate_unique_source_names()</code>","text":"<p>Validate that all column names are unique.</p> <p>Raises:</p> Type Description <code>FormatValidationError</code> <p>If duplicate column names are found</p> Source code in <code>src/core/data_types.py</code> <pre><code>def validate_unique_source_names(self):\n    \"\"\"Validate that all column names are unique.\n\n    Raises:\n        FormatValidationError: If duplicate column names are found\n    \"\"\"\n    column_names = [col.source_name for col in self.columns]\n    unique_names = set(column_names)\n    if len(column_names) != len(unique_names):\n        duplicates = [name for name in unique_names if column_names.count(name) &gt; 1]\n        raise FormatValidationError(\n            f\"Duplicate column names in table {self.name}\",\n            details={\"table_name\": self.name, \"duplicate_columns\": duplicates},\n        )\n</code></pre>"},{"location":"api/core/#src.core.data_types.TimestampType","title":"<code>TimestampType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Common types of timestamp format, ensuring correct conversion</p> Source code in <code>src/core/data_types.py</code> <pre><code>class TimestampType(Enum):\n    \"\"\"Common types of timestamp format, ensuring correct conversion\"\"\"\n\n    UNIX_SECONDS = \"unix_seconds\"\n    UNIX_MILLISECONDS = \"unix_milliseconds\"\n    UNIX_MICROSECONDS = \"unix_microseconds\"\n    ISO_8601 = \"iso_8601\"\n    UNKNOWN = \"unknown\"\n</code></pre>"},{"location":"api/core/#src.core.data_types.Unit","title":"<code>Unit</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Supported units of measurement.</p> Source code in <code>src/core/data_types.py</code> <pre><code>class Unit(Enum):\n    \"\"\"Supported units of measurement.\"\"\"\n\n    MGDL = \"mg/dL\"  # Blood glucose in mg/dL\n    MMOL = \"mmol/L\"  # Blood glucose in mmol/L\n    UNITS = \"U\"  # Insulin units\n    GRAMS = \"g\"  # Carbohydrates in grams\n</code></pre>"},{"location":"api/core/#key-components","title":"Key Components","text":""},{"location":"api/core/#filetype","title":"FileType","text":"<pre><code>class FileType(Enum):\n    \"\"\"Supported file types for diabetes data.\"\"\"\n    SQLITE = \"sqlite\"\n    CSV = \"csv\"\n    JSON = \"json\"\n    XML = \"xml\"\n</code></pre> <p>Usage</p> <p>Used to specify and validate input file types during format detection.</p>"},{"location":"api/core/#datatype","title":"DataType","text":"<pre><code>class DataType(Enum):\n    \"\"\"Core diabetes data types.\"\"\"\n    CGM = auto()        # Continuous glucose monitoring data\n    BGM = auto()        # Blood glucose meter readings\n    INSULIN = auto()    # Insulin doses\n    INSULIN_META = auto() # Insulin metadata\n    CARBS = auto()      # Carbohydrate intake\n    NOTES = auto()      # Text notes/comments\n</code></pre> <p>Example</p> <pre><code>from src.core.data_types import DataType\n\n# Check if data is CGM reading\nif column.data_type == DataType.CGM:\n    process_cgm_data(column)\n</code></pre>"},{"location":"api/core/#timestamptype","title":"TimestampType","text":"<pre><code>class TimestampType(Enum):\n    \"\"\"Common types of timestamp format.\"\"\"\n    UNIX_SECONDS = \"unix_seconds\"\n    UNIX_MILLISECONDS = \"unix_milliseconds\"\n    UNIX_MICROSECONDS = \"unix_microseconds\"\n    ISO_8601 = \"iso_8601\"\n    UNKNOWN = \"unknown\"\n</code></pre> <p>Important</p> <p>All timestamps are converted to UTC during processing.</p>"},{"location":"api/core/#columnrequirement","title":"ColumnRequirement","text":"<pre><code>class ColumnRequirement(Enum):\n    \"\"\"Defines column validation requirements.\"\"\"\n    CONFIRMATION_ONLY = auto()    # Just needs to exist\n    REQUIRED_WITH_DATA = auto()   # Must exist with data\n    REQUIRED_NULLABLE = auto()    # Can have missing values\n    OPTIONAL = auto()             # May not exist\n</code></pre>"},{"location":"api/core/#unit","title":"Unit","text":"<pre><code>class Unit(Enum):\n    \"\"\"Supported units of measurement.\"\"\"\n    MGDL = \"mg/dL\"    # Blood glucose\n    MMOL = \"mmol/L\"   # Blood glucose\n    UNITS = \"U\"       # Insulin\n    GRAMS = \"g\"       # Carbohydrates\n</code></pre>"},{"location":"api/core/#columnmapping","title":"ColumnMapping","text":"<pre><code>@dataclass\nclass ColumnMapping:\n    \"\"\"Maps source columns to standardized data types.\n\n    Args:\n        source_name: Original column name\n        data_type: Column data type\n        unit: Unit of measurement\n        requirement: Validation requirement\n        is_primary: Primary column flag\n    \"\"\"\n    source_name: str\n    data_type: Optional[DataType] = None\n    unit: Optional[Unit] = None\n    requirement: ColumnRequirement = ColumnRequirement.REQUIRED_WITH_DATA\n    is_primary: bool = True\n</code></pre> <p>ColumnMapping Example</p> <pre><code>    glucose = ColumnMapping(\n        source_name=\"calculated_value\",\n        data_type=DataType.CGM,\n        unit=Unit.MGDL\n    )\n</code></pre>"},{"location":"api/core/#tablestructure","title":"TableStructure","text":"<pre><code>@dataclass\nclass TableStructure:\n    \"\"\"Defines data table structure.\n\n    Args:\n        name: Table name\n        timestamp_column: Timestamp column name\n        columns: Column mappings\n\n    Methods:\n        validate_columns(): Ensures table has columns\n        validate_unique_source_names(): Checks for duplicates\n        validate_primary_columns(): Validates primary columns\n    \"\"\"\n    name: str\n    timestamp_column: str\n    columns: List[ColumnMapping]\n</code></pre> <p>Validation Methods</p> <p>All validation methods raise <code>FormatValidationError</code> on failure</p>"},{"location":"api/core/#fileconfig","title":"FileConfig","text":"<pre><code>@dataclass\nclass FileConfig:\n    \"\"\"Configuration for device format file.\n\n    Args:\n        name_pattern: Filename pattern\n        file_type: File type enum\n        tables: Table structures\n\n    Validates:\n        - At least one table\n        - CSV files have one unnamed table\n    \"\"\"\n    name_pattern: str\n    file_type: FileType\n    tables: List[TableStructure]\n</code></pre>"},{"location":"api/core/#deviceformat","title":"DeviceFormat","text":"<pre><code>@dataclass\nclass DeviceFormat:\n    \"\"\"Complete device format specification.\n\n    Args:\n        name: Format name\n        files: File configurations\n\n    Methods:\n        __str__: Returns format name and data types\n    \"\"\"\n    name: str\n    files: List[FileConfig]\n</code></pre> <p>Complete Format Example</p> <pre><code>    xdrip_format = DeviceFormat(\n        name=\"xdrip_sqlite\",\n        files=[\n            FileConfig(\n                name_pattern=\"*.sqlite\",\n                file_type=FileType.SQLITE,\n                tables=[\n                    TableStructure(\n                        name=\"BgReadings\",\n                        timestamp_column=\"timestamp\",\n                        columns=[\n                            ColumnMapping(\n                                source_name=\"calculated_value\",\n                                data_type=DataType.CGM,\n                                unit=Unit.MGDL\n                            )\n                        ]\n                    )\n                ]\n            )\n        ]\n    )\n</code></pre>"},{"location":"getting-started/","title":"Overview","text":"Getting Started with CGM Data Processor <p>Process your diabetes device data in minutes</p>"},{"location":"getting-started/#overview","title":"\ud83c\udfaf Overview","text":"<p>CGM Data Processor is a Python framework that helps you:</p> <ul> <li>Import data from multiple diabetes management systems</li> <li>Process and align CGM readings with treatment data</li> <li>Export cleaned, validated datasets for analysis</li> </ul>"},{"location":"getting-started/#requirements","title":"\ud83d\udccb Requirements","text":"<ul> <li>Python 3.10 or higher</li> <li>Supported data formats: SQLite, CSV, XML</li> <li>Basic Python knowledge for custom analysis</li> </ul>"},{"location":"getting-started/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>Installation Guide - Set up the package</li> <li>Basic Usage - Process your first dataset</li> <li>Data Import - Learn about supported formats</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"Installation <p>Set up CGM Data Processor for development</p>"},{"location":"getting-started/installation/#development-setup","title":"\ud83d\udee0\ufe0f Development Setup","text":"<ul> <li>Python 3.10+ required</li> <li>Poetry for dependency management</li> <li>Git for version control</li> </ul> <pre><code># Clone repository\ngit clone https://github.com/Warren8824/cgm-data-processor.git\ncd cgm-data-processor\n\n# Install dependencies\npoetry install\n\n# Setup pre-commit hooks\npoetry run pre-commit install\n</code></pre> <p>\u2705 Verify Installation</p> <pre><code>from src.core.format_registry import FormatRegistry\n\n# Should print available formats\nregistry = FormatRegistry()\nprint(registry.formats)\n</code></pre>"},{"location":"getting-started/quickstart/basic/","title":"Basic Usage","text":"Basic Usage <p>Process and analyze your diabetes data</p>"},{"location":"getting-started/quickstart/basic/#command-line-usage","title":"\ud83d\ude80 Command Line Usage","text":"<ul> <li>Basic: <code>python -m src.cli data.sqlite</code></li> <li>Custom output: <code>python -m src.cli data.sqlite --output my_folder</code></li> <li>Debug mode: <code>python -m src.cli data.sqlite --debug</code></li> </ul>"},{"location":"getting-started/quickstart/basic/#processing-options","title":"\u2699\ufe0f Processing Options","text":"<pre><code>python -m src.cli data.sqlite \\\n    --interpolation-limit 6   # Max CGM gaps to fill (6 = 30 mins)\n    --bolus-limit 10.0       # Max bolus insulin units\n    --max-dose 20.0          # Max valid insulin dose\n    --output ./my_analysis   # Output location\n</code></pre>"},{"location":"getting-started/quickstart/basic/#parameter-guide","title":"\ud83d\udcca Parameter Guide","text":"<ul> <li><code>interpolation-limit</code>: Gaps larger than this won't be filled (default: 4 = 20 mins)</li> <li><code>bolus-limit</code>: Doses above this classified as basal (default: 8.0 units)</li> <li><code>max-dose</code>: Doses above this flagged as invalid (default: 15.0 units)</li> </ul>"},{"location":"getting-started/quickstart/import/","title":"Data Import","text":"Data Import <p>Supported formats and data sources</p>"},{"location":"getting-started/quickstart/import/#supported-devices","title":"\ud83d\udcf1 Supported Devices","text":"<ul> <li>XDrip+ (SQLite format)</li> <li>Dexcom (CSV format - coming soon)</li> <li>Freestyle Libre (CSV format - coming soon)</li> </ul>"},{"location":"getting-started/quickstart/import/#xdrip-export-guide","title":"\ud83d\udcbe XDrip+ Export Guide","text":"<ul> <li>Open XDrip+</li> <li>Navigate to Settings \u2192 Data Export</li> <li>Select \"Export Database\"</li> <li>Save the .sqlite file</li> </ul>"},{"location":"getting-started/quickstart/import/#data-requirements","title":"\ud83d\udd0d Data Requirements","text":"<ul> <li>CGM readings with timestamps</li> <li>Treatment records (insulin, carbs)</li> <li>No missing required columns</li> <li>Valid data ranges for readings</li> </ul>"},{"location":"getting-started/quickstart/processing/","title":"Data Processing","text":"Data Processing <p>Understanding and configuring data processing options</p>"},{"location":"getting-started/quickstart/processing/#processing-parameters","title":"\ud83d\udd04 Processing Parameters","text":"<ul> <li>CGM Gap Handling: How many missing readings to interpolate</li> <li>Insulin Classification: Thresholds for bolus vs basal</li> <li>Data Validation: Maximum valid insulin doses</li> </ul>"},{"location":"getting-started/quickstart/processing/#configuration-examples","title":"\u2699\ufe0f Configuration Examples","text":"<pre><code># Conservative gap filling (15 mins max)\npython -m src.cli data.sqlite --interpolation-limit 3\n\n# Higher insulin thresholds\npython -m src.cli data.sqlite --bolus-limit 12.0 --max-dose 25.0\n\n# Strict validation\npython -m src.cli data.sqlite --bolus-limit 6.0 --max-dose 12.0\n</code></pre>"},{"location":"getting-started/quickstart/processing/#output-structure","title":"\ud83d\udcca Output Structure","text":"<ul> <li>complete_dataset/: Full processed data with applied parameters</li> <li>monthly/: Split data maintaining processing settings</li> <li>processing_notes.json: Configuration and quality metrics</li> </ul>"},{"location":"user-guide/data-types/","title":"Data Types & Processing","text":"Data Types <p>Core data types and their processing</p>"},{"location":"user-guide/data-types/#cgm-data","title":"\ud83d\udcc8 CGM Data","text":"<ul> <li>5-minute glucose readings</li> <li>Gap detection and interpolation</li> <li>Units: mg/dL and mmol/L</li> <li>Quality metrics: completeness, noise levels</li> </ul>"},{"location":"user-guide/data-types/#insulin-data","title":"\ud83d\udc89 Insulin Data","text":"<ul> <li>Bolus: Meal and correction doses</li> <li>Basal: Long-acting background insulin</li> <li>Automatic classification based on dose size</li> <li>Metadata support for insulin types</li> </ul>"},{"location":"user-guide/data-types/#carbohydrate-data","title":"\ud83c\udf4e Carbohydrate Data","text":"<ul> <li>Meal entries in grams</li> <li>Timestamp alignment with insulin</li> <li>Minimum 1g threshold</li> </ul>"},{"location":"user-guide/data-types/#notes-data","title":"\ud83d\udcdd Notes Data","text":"<ul> <li>Treatment notes and events</li> <li>Timestamped annotations</li> <li>Flexible text storage</li> </ul>"},{"location":"user-guide/errors/","title":"Error Handling","text":"Error Handling <p>Common errors and troubleshooting</p>"},{"location":"user-guide/errors/#common-errors","title":"\u274c Common Errors","text":"<ul> <li>FormatDetectionError: File format not recognized</li> <li>DataProcessingError: Invalid or corrupt data</li> <li>AlignmentError: Cannot align datasets</li> <li>FileAccessError: Cannot read input file</li> </ul>"},{"location":"user-guide/errors/#troubleshooting","title":"\ud83d\udd0d Troubleshooting","text":"<pre><code># Enable debug mode for detailed errors\npython -m src.cli data.sqlite --debug\n\n# Common debug output:\n\u2713 Format Detection Successful\n\u2717 Data Reading Failed: Missing required columns\n   Details: Table 'BgReadings' missing 'calculated_value'\n</code></pre>"},{"location":"user-guide/errors/#data-validation-errors","title":"\ud83d\udeab Data Validation Errors","text":"<ul> <li>Invalid glucose values (outside 40-400 mg/dL)</li> <li>Insulin doses exceeding max_dose</li> <li>Missing timestamps or required fields</li> <li>Duplicate timestamps in CGM data</li> </ul>"},{"location":"user-guide/formats/","title":"Supported Formats","text":"Supported File Formats <p>Supported diabetes device data formats</p>"},{"location":"user-guide/formats/#xdrip-sqlite","title":"\ud83d\udcf1 XDrip+ SQLite","text":"<ul> <li>Default SQLite database from XDrip+</li> <li>Contains BgReadings and Treatments tables</li> <li>Full CGM and treatment data support</li> <li>Export: Settings \u2192 Data Export \u2192 Export Database</li> </ul>"},{"location":"user-guide/formats/#schema-structure","title":"\ud83d\udcd1 Schema Structure","text":"<pre><code>-- BgReadings Table\ntimestamp          -- UTC timestamp\ncalculated_value   -- Glucose in mg/dL\nraw_data          -- Raw sensor data\n\n-- Treatments Table\ntimestamp    -- UTC timestamp\ninsulin      -- Insulin dose in units\ninsulinJSON  -- Insulin type metadata\ncarbs       -- Carbohydrates in grams\nnotes       -- Treatment notes\n</code></pre>"},{"location":"user-guide/formats/#other-formats-coming-soon","title":"\ud83d\udd04 Other Formats (Coming Soon)","text":"<ul> <li>Dexcom CSV Export</li> <li>Freestyle Libre CSV</li> <li>Nightscout Data</li> </ul>"},{"location":"user-guide/formats/#add-custom-file-formats","title":"Add Custom File Formats","text":"<p>Check out our API and developer guide if you would like to add your own formats to the program.</p>"}]}